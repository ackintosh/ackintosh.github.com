<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>暁</title>
    <link>http://ackintosh.github.io/</link>
    <description>Recent content on 暁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2012</copyright>
    <lastBuildDate>Wed, 04 May 2016 02:16:17 +0900</lastBuildDate>
    <atom:link href="http://ackintosh.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Snidel 0.6 をリリースしました</title>
      <link>http://ackintosh.github.io/blog/2016/05/04/snidel_0_6_0/</link>
      <pubDate>Wed, 04 May 2016 02:16:17 +0900</pubDate>
      
      <guid>http://ackintosh.github.io/blog/2016/05/04/snidel_0_6_0/</guid>
      <description>

&lt;p&gt;外部的なインターフェースは変わっていませんが、&lt;br /&gt;
内部的なアーキテクチャを大幅に変更しました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ackintosh/snidel/releases/tag/0.6.0&#34;&gt;Release 0.6.0 · ackintosh/snidel&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;従来のアーキテクチャ:4d7ad6f73d7201295106d2c9c2dab7a0&#34;&gt;従来のアーキテクチャ&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ackintosh/snidel/master/images/original_architecture.png&#34; alt=&#34;original_architecture.png&#34; /&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Snidel::fork() を実行したタイミングで子プロセスを fork し、
生成された子プロセスはトークンが回ってくるまで待機する&lt;br /&gt;
（同時実行数を制御するために Snidel\Token オブジェクトを使用）&lt;/li&gt;
&lt;li&gt;予め設定された同時実行数以下までの子プロセスは即座に処理が開始されるが、それ以降の子プロセスは先に実行中のプロセスが完了するまでは待機状態になる&lt;/li&gt;
&lt;li&gt;子プロセスは処理を実行して結果を共有メモリに保存し、最後に(Snidel::__destruct()で)トークンを返却する&lt;/li&gt;
&lt;li&gt;Snidel::wait() または Snidel::get() を実行することで親プロセスが、各子プロセスと対になる共有メモリから実行結果を取得する&lt;br /&gt;
(実行中・待機中の子プロセスがあれば、それらが完了するまで親プロセスは待機する)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;問題点:4d7ad6f73d7201295106d2c9c2dab7a0&#34;&gt;問題点&lt;/h3&gt;

&lt;p&gt;Snidel::fork() で即座に子プロセスを fork するため、&lt;br /&gt;
場合によっては瞬間的に大量の fork が発生するため下記の問題がありました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;fork の負荷&lt;/li&gt;
&lt;li&gt;大量の待機プロセスが発生するためプロセス数の上限に達してしまう可能性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上記を避けるために単純に fork 数をコントロールしようとすると&lt;br /&gt;
同時実行数を超えた Snidel::fork() 呼び出しの際に親プロセス (Snidel を利用する側) を&lt;br /&gt;
実行中の子プロセスが終了するまで待機させなければいけません。&lt;/p&gt;

&lt;h3 id=&#34;改善後のアーキテクチャ:4d7ad6f73d7201295106d2c9c2dab7a0&#34;&gt;改善後のアーキテクチャ&lt;/h3&gt;

&lt;p&gt;Master-Workerモデルに変更しました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ackintosh/snidel/master/images/master_worker.png&#34; alt=&#34;master_worker.png&#34; /&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;初回の Snidel::fork() を実行したタイミングで Master プロセスを fork する&lt;/li&gt;
&lt;li&gt;実行したい処理は専用のキュー(Task Queue)に追加する&lt;/li&gt;
&lt;li&gt;Master プロセスが Task Queue から処理を取り出し、それを実行する Worker プロセスを fork する&lt;br /&gt;
（Worker の同時起動数を制御するために Snidel\Token オブジェクトを使用）&lt;/li&gt;
&lt;li&gt;Worker プロセスが実行結果を専用のキュー(Result Queue)に追加し、トークンを返却する&lt;/li&gt;
&lt;li&gt;Snidel::wait() または Snidel::get() を実行することで、Result Queue から実行結果を取得する&lt;br /&gt;
(実行中・未実行のタスクがあれば、それらが完了するまで待機する)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これにより、親プロセス(内部的には Owner プロセスと呼んでいます)は&lt;br /&gt;
実行したい処理をキューに追加するだけで良くなって、&lt;br /&gt;
あとは Master プロセスが Worker の同時起動数に気を配りながらイイ感じに進めてくれます。&lt;br /&gt;
もちろん、Master-Worker が働いている間 Owner は他の仕事ができます。&lt;/p&gt;

&lt;p&gt;改善内容については以上になります。&lt;/p&gt;

&lt;p&gt;ただ現状、従来のアーキテクチャを完全に置き換えたわけではなく、&lt;br /&gt;
Snidel::map() に関連する処理の中で内部的に利用されていて、今後こちらも置き換える予定です。&lt;br /&gt;
Snidel::map() はバージョン0.2で実装した機能で、リリース時の記事で「複数の処理を並列につなげて実行」という項目で紹介しています。&lt;br /&gt;
&lt;a href=&#34;http://ackintosh.github.io/blog/2015/11/08/snidel_0_2_0/&#34;&gt;Snidel 0.2 をリリースしました&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>最近読んだ本 (〜2016/04)</title>
      <link>http://ackintosh.github.io/blog/2016/05/01/books_201604/</link>
      <pubDate>Sun, 01 May 2016 19:03:34 +0900</pubDate>
      
      <guid>http://ackintosh.github.io/blog/2016/05/01/books_201604/</guid>
      <description>

&lt;p&gt;人工知能がアツいようなのでとりあえず１冊読んでみたのと&lt;br /&gt;
近いうちに環境が変わるので、色々と足りないところの予備知識を準備するのがメイン。&lt;/p&gt;

&lt;h3 id=&#34;人工知能は人間を超えるか:cdb2047052c76a7a2041c96c97ab67f5&#34;&gt;人工知能は人間を超えるか&lt;/h3&gt;

&lt;p&gt;&lt;a  href=&#34;http://www.amazon.co.jp/gp/product/B00UAAK07S/ref=as_li_tf_il?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=B00UAAK07S&amp;linkCode=as2&amp;tag=akihito0a-22&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=B00UAAK07S&amp;Format=_SL250_&amp;ID=AsinImage&amp;MarketPlace=JP&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=akihito0a-22&#34; &gt;&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=akihito0a-22&amp;l=as2&amp;o=9&amp;a=B00UAAK07S&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;スティーブズ-4:cdb2047052c76a7a2041c96c97ab67f5&#34;&gt;スティーブズ(4)&lt;/h3&gt;

&lt;p&gt;&lt;a  href=&#34;http://www.amazon.co.jp/gp/product/4091875696/ref=as_li_tf_il?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=4091875696&amp;linkCode=as2&amp;tag=akihito0a-22&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=4091875696&amp;Format=_SL250_&amp;ID=AsinImage&amp;MarketPlace=JP&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=akihito0a-22&#34; &gt;&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=akihito0a-22&amp;l=as2&amp;o=9&amp;a=4091875696&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;スクラム実践入門:cdb2047052c76a7a2041c96c97ab67f5&#34;&gt;スクラム実践入門&lt;/h3&gt;

&lt;p&gt;「ソフトウェア開発は難しい」という現実を理解することから始まる。&lt;br /&gt;
5W1Hによる問題の分解から、スクラムにおける対処方法、プロダクトオーナー・スクラムマスターの必要性にスムーズに繋がっていく展開が、読んでいてとても気持ちよかった。
また、随所で引用される記事・論文等の豊富さが印象的だった。&lt;/p&gt;

&lt;p&gt;途中で紹介されている「戦略思考コンプリートブック」はとりあえずウィッシュリストに追加した。&lt;/p&gt;

&lt;p&gt;&lt;a  href=&#34;http://www.amazon.co.jp/gp/product/4774172367/ref=as_li_tf_il?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=4774172367&amp;linkCode=as2&amp;tag=akihito0a-22&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=4774172367&amp;Format=_SL250_&amp;ID=AsinImage&amp;MarketPlace=JP&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=akihito0a-22&#34; &gt;&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=akihito0a-22&amp;l=as2&amp;o=9&amp;a=4774172367&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;入門-puppet:cdb2047052c76a7a2041c96c97ab67f5&#34;&gt;入門 Puppet&lt;/h3&gt;

&lt;p&gt;1つ1つの章がコンパクトなのでリズムよく進められた。&lt;br /&gt;
fluentd や serverspec を使う章があって、自分にとっては一石三鳥感があった。&lt;br /&gt;
最後の章で「プログラマの三大美徳（無精・短気・傲慢）」と照らし合わせて Puppet を使うモチベーションを再確認させてくれるのが良かった。&lt;/p&gt;

&lt;p&gt;&lt;a  href=&#34;http://www.amazon.co.jp/gp/product/B00CL92JC0/ref=as_li_tf_il?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=B00CL92JC0&amp;linkCode=as2&amp;tag=akihito0a-22&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=B00CL92JC0&amp;Format=_SL250_&amp;ID=AsinImage&amp;MarketPlace=JP&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=akihito0a-22&#34; &gt;&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=akihito0a-22&amp;l=as2&amp;o=9&amp;a=B00CL92JC0&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;web-api-the-good-parts:cdb2047052c76a7a2041c96c97ab67f5&#34;&gt;Web API The Good Parts&lt;/h3&gt;

&lt;p&gt;&lt;a  href=&#34;http://www.amazon.co.jp/gp/product/4873116864/ref=as_li_qf_sp_asin_il?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=4873116864&amp;linkCode=as2&amp;tag=akihito0a-22&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=4873116864&amp;Format=_SL250_&amp;ID=AsinImage&amp;MarketPlace=JP&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=akihito0a-22&#34; &gt;&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=akihito0a-22&amp;l=as2&amp;o=9&amp;a=4873116864&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;プログラミングでメシが食えるか:cdb2047052c76a7a2041c96c97ab67f5&#34;&gt;プログラミングでメシが食えるか&lt;/h3&gt;

&lt;p&gt;後輩君が貸してくれたのがきっかけで読んだ。&lt;br /&gt;
2007年 なので内容に少し古さを感じるところはあったが&lt;br /&gt;
自分の得意分野を作って、目に見える形にする(アウトプットする)のが大事、ということを再認識させてもらった。&lt;/p&gt;

&lt;p&gt;&lt;a  href=&#34;http://www.amazon.co.jp/gp/product/479801558X/ref=as_li_tf_il?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=479801558X&amp;linkCode=as2&amp;tag=akihito0a-22&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=479801558X&amp;Format=_SL250_&amp;ID=AsinImage&amp;MarketPlace=JP&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=akihito0a-22&#34; &gt;&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=akihito0a-22&amp;l=as2&amp;o=9&amp;a=479801558X&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;blue-giant-8:cdb2047052c76a7a2041c96c97ab67f5&#34;&gt;BLUE GIANT(8)&lt;/h3&gt;

&lt;p&gt;&lt;a  href=&#34;http://www.amazon.co.jp/gp/product/B01DEJ6H7S/ref=as_li_tf_il?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=B01DEJ6H7S&amp;linkCode=as2&amp;tag=akihito0a-22&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=B01DEJ6H7S&amp;Format=_SL250_&amp;ID=AsinImage&amp;MarketPlace=JP&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=akihito0a-22&#34; &gt;&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=akihito0a-22&amp;l=as2&amp;o=9&amp;a=B01DEJ6H7S&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Snidel 0.5 をリリースしました</title>
      <link>http://ackintosh.github.io/blog/2016/04/04/snidel_0_5_0/</link>
      <pubDate>Mon, 04 Apr 2016 12:44:06 +0900</pubDate>
      
      <guid>http://ackintosh.github.io/blog/2016/04/04/snidel_0_5_0/</guid>
      <description>&lt;p&gt;引き続き内部のリファクタリングに加えて、&lt;br /&gt;
今回のリリースでは Snidel::get() の返り値を変更しました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ackintosh/snidel/releases/tag/0.5.0&#34; target=&#34;_blank&#34;&gt;Release 0.5.0 · ackintosh/snidel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これまでは子プロセス群が返す値を単純に配列で返していたのですが&lt;br /&gt;
バージョン 0.5 では配列の代わりに Snidel\ForkCollection のインスタンスを返します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Snidel::get() returns instance of Snidel\ForkCollection
$forkCollection = $snidel-&amp;gt;get();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Snidel\ForkCollection は Snidel\Fork の集合で、&lt;br /&gt;
Snidel\Fork が子プロセスの実行結果についての詳細を把握しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Snidel\ForkCollection implements \Iterator
foreach ($forkCollection as $fork) {
    echo $fork-&amp;gt;getPid();// プロセスID
    echo $fork-&amp;gt;getOutput();// 標準出力
    echo $fork-&amp;gt;getReturn();// 返り値
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Snidel\ForkCollection::toArray() を使えばこれまで通り、返り値だけを配列で取得することもできます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var_dump($forkCollection-&amp;gt;toArray());
// array(3) {
//   [0]=&amp;gt;
//   string(3) &amp;quot;bar&amp;quot;
//   [1]=&amp;gt;
//   string(3) &amp;quot;foo&amp;quot;
//   [2]=&amp;gt;
//   string(3) &amp;quot;baz&amp;quot;
// }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、ソースコードの静的解析ツール Scrutinizer のスコアが&lt;br /&gt;
9.56 まで改善したのでこの場で静かにアピールしておきたいと思います。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dl.dropboxusercontent.com/u/22083548/octopress/snidel_0_5_0.png&#34; alt=&#34;scrutinizer&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Snidel 0.4 をリリースしました</title>
      <link>http://ackintosh.github.io/blog/2016/04/04/snidel_0_4_0/</link>
      <pubDate>Mon, 04 Apr 2016 12:14:53 +0900</pubDate>
      
      <guid>http://ackintosh.github.io/blog/2016/04/04/snidel_0_4_0/</guid>
      <description>&lt;p&gt;リリース日は 2016-02-21 なのでブログに書くのがだいぶ遅くなってしまいました。&lt;/p&gt;

&lt;p&gt;PHP5.2 のサポートを終了したのが大きな変更点です。&lt;br /&gt;
これまでは諸事情によりサポートせざるを得なかったのですがようやく。。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;embedly-card&#34; data-card-key=&#34;916e111541fe433792c1330eb7eba55b&#34; data-card-type=&#34;article&#34;&gt;&lt;h4&gt;&lt;a href=&#34;https://github.com/ackintosh/snidel/releases/tag/0.4.0&#34;&gt;ackintosh/snidel&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;snidel - A multi-process container.&lt;/p&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//cdn.embedly.com/widgets/platform.js&#34; charset=&#34;UTF-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;ちなみに 0.3 が PHP5.2 をサポートする最後のバージョンになっています。&lt;/p&gt;

&lt;p&gt;上記に伴い、名前空間や無名関数を使うように改修したり&lt;br /&gt;
PHP5.2 でパースエラーにならないようにテストコードを変な書き方をしていた箇所を修正しています。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CloudFrontでURL振り分けをするときの注意点</title>
      <link>http://ackintosh.github.io/blog/2016/02/24/l7switching-with-cf/</link>
      <pubDate>Wed, 24 Feb 2016 21:16:42 +0900</pubDate>
      
      <guid>http://ackintosh.github.io/blog/2016/02/24/l7switching-with-cf/</guid>
      <description>

&lt;p&gt;最近仕事で担当しているサービスをオンプレからAWSに移行しました。&lt;/p&gt;

&lt;p&gt;ビジネスの都合で短期間で移行しなければいけなかったり、&lt;br /&gt;
AWSに関しては、&lt;br /&gt;
個人的に趣味で少し触った程度だったり、&lt;br /&gt;
会社としてもこれからノウハウを溜めていこうという段階だったので手探り状態で&lt;br /&gt;
大変でしたが周りの方々にフォローしていただきながらなんとか完了することができました。&lt;/p&gt;

&lt;p&gt;この記事では移行の際にハマったことを共有します。&lt;/p&gt;

&lt;h2 id=&#34;cloudfront-で-url振り分けをする:ca709987244aa21a0352b3870aa9a35d&#34;&gt;CloudFront で URL振り分けをする&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://example.com/aaa&#34;&gt;http://example.com/aaa&lt;/a&gt; のアクセスはサーバー(群)A&lt;br /&gt;
&lt;a href=&#34;http://example.com/bbb&#34;&gt;http://example.com/bbb&lt;/a&gt; のアクセスはサーバー(群)B&lt;br /&gt;
といったかたちで処理を分けたい場合、通常はL7ロードバランサの機能を利用しますが&lt;br /&gt;
ELB にはURLで振り分ける機能がありません。&lt;/p&gt;

&lt;p&gt;そのため、代わりに CloudFront に オリジンやビヘイビアを複数設定することで&lt;br /&gt;
L7 スイッチとして使うのが手軽で運用も楽です。&lt;/p&gt;

&lt;p&gt;設定についての詳細は参考URLをご参照ください。&lt;/p&gt;

&lt;h4 id=&#34;参考url:ca709987244aa21a0352b3870aa9a35d&#34;&gt;参考URL&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mil-o.jp/yb/elb-l7/&#34; target=&#34;_blank&#34;&gt;[AWS]ELBがURLで振り分けできない問題はCloudFrontでなんとかする&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://forums.aws.amazon.com/thread.jspa?threadID=137123&#34; target=&#34;_blank&#34;&gt;ELBでURLごとにサーバー振り分け&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;注意点:ca709987244aa21a0352b3870aa9a35d&#34;&gt;注意点&lt;/h2&gt;

&lt;p&gt;ですがこの方法だと フィーチャーフォン で HTTPS ページが閲覧できなくなります。&lt;br /&gt;
（全ての機種で閲覧できなくなるかはわかりませんが、10機種ほどで確認したら全滅でした）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;フィーチャーフォンはサポートしていない&lt;/li&gt;
&lt;li&gt;HTTPS は利用していない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といった場合は該当しません。&lt;/p&gt;

&lt;p&gt;CloudFront はデフォルトではネームベース( SNI )の独自SSL機能を提供していて&lt;br /&gt;
これにはクライアント側も SNI に対応している必要がありますが&lt;br /&gt;
フィーチャーフォンは対応していないようです。&lt;br /&gt;
※ 実際にはフィーチャーフォン以外にも IE6 等の古いブラウザも対応していません。&lt;br /&gt;
　→ &lt;a href=&#34;https://ja.wikipedia.org/wiki/Server_Name_Indication#.E5.AF.BE.E5.BF.9C.E7.8A.B6.E6.B3.81&#34; target=&#34;_blank&#34;&gt;Wikipedia に対応状況がまとまっています&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;SNI とは SSL/TLS の拡張仕様で、サーバー側が１つのグローバルIPアドレスで複数の証明書を扱えるようになるメリットがあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/Server_Name_Indication&#34; target=&#34;_blank&#34;&gt;Server Name Indication - Wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;回避方法:ca709987244aa21a0352b3870aa9a35d&#34;&gt;回避方法&lt;/h4&gt;

&lt;p&gt;AWSドキュメントにいくつか紹介されています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/AmazonCloudFront/latest/DeveloperGuide/SecureConnections.html#cnames-https-dedicated-ip-or-sni&#34; target=&#34;_blank&#34;&gt;CloudFront で HTTPS リクエストを供給する方法の選択&lt;/a&gt;&lt;br /&gt;
　→ SNI を使用した HTTPS リクエストの供給（ほとんどのクライアントで動作）&lt;/p&gt;

&lt;p&gt;SNI ではなく専用 IPアドレス を利用する方法がありますが、月額で 600 USD(執筆時点) かかるので、フィーチャーフォン対応のために払うにはだいぶ高い金額なのかなと思います。&lt;/p&gt;

&lt;p&gt;あとは、ユースケース次第ですが、フィーチャーフォン用のサブドメインを用意して&lt;br /&gt;
フィーチャーフォンでは CloudFront を使わない(URLで振り分けをしない)のも有りだと思います。&lt;/p&gt;

&lt;h4 id=&#34;どうしたか:ca709987244aa21a0352b3870aa9a35d&#34;&gt;どうしたか&lt;/h4&gt;

&lt;p&gt;URLで振り分けるのをやめました。&lt;/p&gt;

&lt;p&gt;もともと、オンプレ環境の限られたリソースで&lt;br /&gt;
&amp;ldquo;aaa にアクセスが集中した場合に bbb に影響を出さないように&amp;rdquo; という目的で振り分けしていました。&lt;br /&gt;
ですので サーバーA も サーバーB も同じアプリケーションが動いています。&lt;/p&gt;

&lt;p&gt;クラウドならスケールアップ／スケールアウトが自由自在なので&lt;br /&gt;
&amp;ldquo;やばかったら増強すればいい&amp;rdquo; ということで振り分けるのをやめました。&lt;/p&gt;

&lt;h3 id=&#34;書籍紹介:ca709987244aa21a0352b3870aa9a35d&#34;&gt;書籍紹介&lt;/h3&gt;

&lt;p&gt;こちらの本で AWS の基礎を勉強しました。&lt;br /&gt;
各サービスの概要からバックアップ等の実際の運用について書かれていて、&lt;br /&gt;
知りたいところだけをピックアップして読める構成になっているので大変助かりました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;embedly-card&#34; data-card-key=&#34;916e111541fe433792c1330eb7eba55b&#34;&gt;&lt;h4&gt;&lt;a href=&#34;http://www.amazon.co.jp/o/ASIN/4774176737/gihyojp-22&#34;&gt;Amazon Web Services実践入門 (WEB+DB PRESS plus)&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Amazon公式サイトでAmazon Web Services実践入門 (WEB+DB PRESS plus)を購入すると、Amazon配送商品なら、配送料無料でお届け。Amazonポイント還元本も多数。Amazon.co.jpをお探しなら豊富な品ぞろえのAmazon.co.jp&lt;/p&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//cdn.embedly.com/widgets/platform.js&#34; charset=&#34;UTF-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ペパボテックカンファレンス EC編に行ってきました</title>
      <link>http://ackintosh.github.io/blog/2015/11/15/pbtech_4/</link>
      <pubDate>Sun, 15 Nov 2015 17:27:08 +0900</pubDate>
      
      <guid>http://ackintosh.github.io/blog/2015/11/15/pbtech_4/</guid>
      <description>

&lt;p&gt;いま仕事でECに携わっているのもあって気になったので行ってきました。&lt;/p&gt;

&lt;p&gt;&lt;a class=&#34;embedly-card&#34; href=&#34;http://eventdots.jp/event/573086&#34;&gt;国内No.1 ECサービス開発のすべてを語り尽くします！〜第4回ペパボテックカンファレンスEC編 - dots. [ドッツ]&lt;/a&gt;
&lt;script async src=&#34;//cdn.embedly.com/widgets/platform.js&#34; charset=&#34;UTF-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;事情で途中退席してしまったのですが、&lt;br /&gt;
EC以外でも役に立つ内容でとても刺激になりました。&lt;/p&gt;

&lt;p&gt;途中退席した関係で以下、最初の２つのお話についてしか書けていませんが&lt;br /&gt;
ブログを書くまでが&amp;hellip;ということで。&lt;/p&gt;

&lt;h2 id=&#34;jwtを使った簡易ssoで-徐々にシステムをリニューアルしている話:e2bea448186c875775664c97d0ab5124&#34;&gt;JWTを使った簡易SSOで、徐々にシステムをリニューアルしている話&lt;/h2&gt;

&lt;p&gt;PHPのモノリシックなアプリケーションのカート部分を Angular + Rails API で作りなおして、&lt;br /&gt;
サービス間の認証情報をJWT(ジョット)を使って共有している、というお話。&lt;/p&gt;

&lt;p&gt;JWTを使うことで、わざわざトークンと認証情報の組をストレージに保存したりせず、&lt;br /&gt;
手軽でセキュアに情報を共有できるのは良いなと思いました。&lt;/p&gt;

&lt;p&gt;自分の仕事では、&lt;br /&gt;
音楽系アーティストのファンクラブサイトとECサイトを別システムで展開しているので、&lt;br /&gt;
ログイン情報を共有するのに使えるかなと思いました。&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/kRQfq0XOSom6q9&#34; width=&#34;595&#34; height=&#34;485&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34;&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;//www.slideshare.net/TsuchiKazu/jwt-ssopepabotech&#34; title=&#34;JWTを使った簡易SSOで、徐々にシステムをリニューアルしている話&#34; target=&#34;_blank&#34;&gt;JWTを使った簡易SSOで、徐々にシステムをリニューアルしている話&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;//www.slideshare.net/TsuchiKazu&#34; target=&#34;_blank&#34;&gt;Kazuyoshi Tsuchiya&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;&lt;/p&gt;

&lt;h2 id=&#34;ネクストステージに繋がるインフラ基盤づくり:e2bea448186c875775664c97d0ab5124&#34;&gt;ネクストステージに繋がるインフラ基盤づくり&lt;/h2&gt;

&lt;p&gt;オンプレのレガシー環境をクラウド化したお話。&lt;br /&gt;
最新バージョンに追従できるようになったり属人性が解消して
モチベーション↑↑↑した開発担当者さんの爽やかな笑顔(スライド参照)が印象的でした。&lt;/p&gt;

&lt;p&gt;自分の仕事の環境は まさに改善前の状態に近いので、&lt;br /&gt;
いま抱えてる課題を解決した素敵な事例でした。&lt;/p&gt;

&lt;p&gt;Nyah とか Bayt を知らなかったのでググッてみます。&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;6b3d59d8b9e44e378b7043e18ad6a4c1&#34; data-ratio=&#34;1.33333333333333&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;感想:e2bea448186c875775664c97d0ab5124&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;３番目の鹿さんのお話あたりで退席してしまい最後まで聞けなかったのが残念でしたが、&lt;br /&gt;
みなさんのサービスにかける情熱が伝わってきてとても刺激になりました。&lt;br /&gt;
10年も続くサービスの裏で、登壇された方たちのような素晴らしいチームが継続的に改善を続けてたのかぁと思いを馳せながら聞いていました。&lt;/p&gt;

&lt;p&gt;カート作りなおすときに、ボトルネックにならないようにEC特有の注意点とかがあったのか、とか、&lt;br /&gt;
yano3さんが発表の節々で、「歯を食いしばって頑張った」と仰っていたので&lt;br /&gt;
機会があれば、その辺の大変だったところとかも具体的に聞いてみたいです。&lt;/p&gt;

&lt;p&gt;あと、カレーたべたかった…&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Snidel 0.2 をリリースしました</title>
      <link>http://ackintosh.github.io/blog/2015/11/08/snidel_0_2_0/</link>
      <pubDate>Sun, 08 Nov 2015 16:05:24 +0900</pubDate>
      
      <guid>http://ackintosh.github.io/blog/2015/11/08/snidel_0_2_0/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/ackintosh/snidel&#34; target=&#34;_blank&#34;&gt;Snidel&lt;/a&gt; バージョン 0.2 をリリースしました。&lt;br /&gt;
この記事は、&lt;br /&gt;
追加した３つの機能の紹介と、Snidel を使ってもらって嬉しかった！の話になります。&lt;/p&gt;

&lt;p&gt;個人的に、(実際のアプリケーションで必要とされるかは別として）面白い試みをした機能もありますので興味を持っていただけると嬉しいです。&lt;/p&gt;

&lt;h3 id=&#34;特定の処理結果を取得:ee76cbb32354dec37a8e590548214889&#34;&gt;特定の処理結果を取得&lt;/h3&gt;

&lt;p&gt;処理結果を取得するメソッドとして &lt;code&gt;Snidel::get()&lt;/code&gt; を用意していますが&lt;br /&gt;
並列に処理する関係で、 &lt;code&gt;Shidel::get()&lt;/code&gt; で得られる結果の順番は保証されません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$snidel-&amp;gt;fork($func, &#39;foo&#39;);
$snidel-&amp;gt;fork($func, &#39;bar&#39;);
$snidel-&amp;gt;fork($func, &#39;baz&#39;);

var_dump($snidel-&amp;gt;get());
// * the order of results is not guaranteed. *
// array(3) {
//   [0]=&amp;gt;
//   string(3) &amp;quot;bar&amp;quot;
//   [1]=&amp;gt;
//   string(3) &amp;quot;foo&amp;quot;
//   [2]=&amp;gt;
//   string(3) &amp;quot;baz&amp;quot;
// }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ですので、特定（１つまたは複数）の処理結果を取得したいケースに対応できるように&lt;br /&gt;
処理をフォークする時／結果を取得する時にタグを指定できるようにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$snidel-&amp;gt;fork($func, &#39;foo&#39;, &#39;tag1&#39;);
$snidel-&amp;gt;fork($func, &#39;bar&#39;, &#39;tag1&#39;);
$snidel-&amp;gt;fork($func, &#39;baz&#39;, &#39;tag2&#39;);

var_dump($snidel-&amp;gt;get(&#39;tag1&#39;));
// array(2) {
//   [0]=&amp;gt;
//   string(3) &amp;quot;foo&amp;quot;
//   [1]=&amp;gt;
//   string(3) &amp;quot;bar&amp;quot;
// }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記サンプルコードでは &lt;code&gt;tag1&lt;/code&gt; を指定した処理の結果だけを取得しています。&lt;/p&gt;

&lt;h3 id=&#34;ログの出力:ee76cbb32354dec37a8e590548214889&#34;&gt;ログの出力&lt;/h3&gt;

&lt;p&gt;これは Snidel 自体の開発で必要性を感じて実装しました。&lt;/p&gt;

&lt;p&gt;なかなか意図した動作をしない時に、どのプロセスが・どの順番で・いつ生成されたのかを&lt;br /&gt;
追跡する手段がないと辛いですよね。&lt;/p&gt;

&lt;p&gt;最低限の機能しかない頃は echo しまくるだけで間に合ってたのですが&lt;br /&gt;
機能追加を重ねるごとに辛くなってきたので、ログの出力先として resource をセットできるようにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$fp = fopen(&#39;php://stdout&#39;, &#39;w&#39;);
$snidel-&amp;gt;setLoggingDestination($fp);

$snidel-&amp;gt;fork($func, &#39;foo&#39;);
// [info][26304(p)] created child process. pid: 26306
// [info][26306(c)] waiting for the token to come around.
// ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記サンプルコードでは標準出力にプロセス生成などのログが出力されています。&lt;/p&gt;

&lt;h3 id=&#34;複数の処理を並列につなげて実行:ee76cbb32354dec37a8e590548214889&#34;&gt;複数の処理を並列につなげて実行&lt;/h3&gt;

&lt;p&gt;個人的に、(実際のアプリケーションで必要とされるかは別として）面白い試みをした機能です。&lt;/p&gt;

&lt;p&gt;A、B、C ３つの処理を続けて処理する（Aの結果をBが処理し、Bの結果をCが処理する）ケースで&lt;br /&gt;
３つの処理それぞれを並列に実行することができます。&lt;br /&gt;
↑を読んでも、いまいちイメージが伝わらないと思いますがとりあえず使い方を書いていきます。&lt;/p&gt;

&lt;p&gt;まず &lt;code&gt;Snidel::map()&lt;/code&gt; に最初の処理Aと、処理Aを適用する配列を渡します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$map = $snidel-&amp;gt;map($args, function ($arg) {
    // do something. (A)
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして &lt;code&gt;then()&lt;/code&gt; で後続の処理を指定していきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$map-&amp;gt;then(function ($arg) {
    // do something. (B)
})-&amp;gt;then(function ($arg) {
    // do something. (C)
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に &lt;code&gt;Snidel::run()&lt;/code&gt; で、定義した処理を実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$snidel-&amp;gt;run($map);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例として、スペース区切りの文字列をキャメルケースに変換する処理を記載します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$args = [
    &#39;BRING ME THE HORIZON&#39;,
    &#39;ARCH ENEMY&#39;,
    &#39;BULLET FOR MY VALENTINE&#39;,
    &#39;RACER X&#39;,
    &#39;OF MICE AND MEN&#39;,
    &#39;AT THE GATES&#39;,
];

$snidel = new Snidel($maxProcs = 2);

// each of the functions are performed in parallel.
$camelize = $snidel-&amp;gt;map($args, function ($arg) {
    return explode(&#39; &#39;, strtolower($arg));
})-&amp;gt;then(function ($arg) {
    return array_map(&#39;ucfirst&#39;, $arg);
})-&amp;gt;then(function ($arg) {
    return implode(&#39;&#39;, $arg);
});

var_dump($snidel-&amp;gt;run($camelize));
// array(6) {
//   [0] =&amp;gt;
//   string(6) &amp;quot;RacerX&amp;quot;
//   [1] =&amp;gt;
//   string(20) &amp;quot;BulletForMyValentine&amp;quot;
//   [2] =&amp;gt;
//   string(9) &amp;quot;ArchEnemy&amp;quot;
//   [3] =&amp;gt;
//   string(17) &amp;quot;BringMeTheHorizon&amp;quot;
//   [4] =&amp;gt;
//   string(10) &amp;quot;AtTheGates&amp;quot;
//   [5] =&amp;gt;
//   string(12) &amp;quot;OfMiceAndMen&amp;quot;
// }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じの実行イメージです。&lt;br /&gt;
青 : 処理A (explode)&lt;br /&gt;
緑 : 処理B (ucfirst)&lt;br /&gt;
黄 : 処理C (implode)&lt;br /&gt;
&lt;iframe src=&#34;https://player.vimeo.com/video/144969743&#34; frameborder=&#34;0&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;p&gt;処理Aが並列数2で開始して 結果を処理Bに渡した後、&lt;br /&gt;
処理Bの開始と同時に、次の処理Aも開始します。
（文章が下手ですいません&amp;hellip;）&lt;/p&gt;

&lt;p&gt;なお、 &lt;strong&gt;下記ではありません&lt;/strong&gt; 。&lt;/p&gt;

&lt;iframe src=&#34;https://player.vimeo.com/video/145030564&#34; frameborder=&#34;0&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;各処理が1秒かかる場合、&lt;br /&gt;
前者が 5秒 で終了するのに対して、後者は 9秒 かかってしまいます。&lt;/p&gt;

&lt;p&gt;ただ、処理は早く終わりますが実際の並列実行数は Snidel のコンストラクタで指定する数より多くなります。&lt;br /&gt;
（例でいえば最大 6になります）&lt;/p&gt;

&lt;p&gt;以上が追加した機能になります。&lt;/p&gt;

&lt;h3 id=&#34;社内で使ってもらえました:ee76cbb32354dec37a8e590548214889&#34;&gt;社内で使ってもらえました!&lt;/h3&gt;

&lt;p&gt;初回リリース時の記事で&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;いい感じにできれば他のプロジェクトでも使えるかもですし。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;と書いていたのですが、社内slackで作ってみました〜と静かにアピールしたら&lt;br /&gt;
実際に使ってもらえて、けっこう成果が出たみたいでめっちゃ嬉しかったです。&lt;br /&gt;
モチベーションになります。&lt;/p&gt;

&lt;p&gt;この記事で紹介した機能は、このモチベーションで実装しました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;初回リリース時の記事&lt;br /&gt;
&lt;a href=&#34;http://ackintosh.github.io/blog/2015/09/29/snidel/&#34;&gt;php で手軽に並列処理をするライブラリ Snidel を作りました&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今後は&amp;hellip;&lt;br /&gt;
初回リリースから１ヶ月ちょっと経って、実装したい機能は一通り終わったのですが、&lt;br /&gt;
テストコードが少なくてちょっと恥ずかしい感じなので&lt;br /&gt;
引き続きそのへんをいじっていきたいと思っています。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>php で手軽に並列処理をするライブラリ Snidel を作りました</title>
      <link>http://ackintosh.github.io/blog/2015/09/29/snidel/</link>
      <pubDate>Tue, 29 Sep 2015 14:24:34 +0900</pubDate>
      
      <guid>http://ackintosh.github.io/blog/2015/09/29/snidel/</guid>
      <description>

&lt;p&gt;シルバーウィーク中に php のライブラリを作りました。&lt;/p&gt;

&lt;p&gt;&lt;a class=&#34;embedly-card&#34; href=&#34;https://github.com/ackintosh/snidel&#34;&gt;ackintosh/snidel&lt;/a&gt;
&lt;script async src=&#34;//cdn.embedly.com/widgets/platform.js&#34; charset=&#34;UTF-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h3 id=&#34;snidel-スナイデル-について:6059c22da48c7213647847cb35fc5a38&#34;&gt;Snidel (スナイデル) について&lt;/h3&gt;

&lt;p&gt;他の言語のマルチスレッド等の並行・並列処理のための機構に近い書き心地で
php で手軽に並列処理をする。というのがコンセプトです。&lt;/p&gt;

&lt;p&gt;子プロセス数の制御に &lt;a href=&#34;http://php.net/manual/ja/function.msg-get-queue.php&#34; target=&#34;_blank&#34;&gt;メッセージキュー&lt;/a&gt;&lt;br /&gt;
プロセス間のデータのやりとりに &lt;a href=&#34;http://php.net/manual/ja/ref.shmop.php&#34; target=&#34;_blank&#34;&gt;共有メモリ&lt;/a&gt;&lt;br /&gt;
を使っています。&lt;/p&gt;

&lt;p&gt;命名に特にこだわりは無いのですが、響きがシュッとしてていいかなと思ってます。&lt;br /&gt;
ただ、この記事を書きながらGoogle翻訳にかけてみたらエストニア語で「薬物使用者を注入」って出てきたので少し怖くなってきました&amp;hellip;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dl.dropboxusercontent.com/u/22083548/octopress/snidel_translate.png&#34; alt=&#34;snidel_translate&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;proc_open() や exec() でコマンドをバックグラウンドで実行するのではなく、&lt;br /&gt;
Callable を別プロセスで実行して、結果を親プロセスが受け取るかたちにしたかったので PCNTL関数 を使うようにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$func = function ($str) {
    sleep(3);
    return $str;
};

$s = time();
$snidel = new Snidel();
$snidel-&amp;gt;fork($func, &#39;foo&#39;);
$snidel-&amp;gt;fork($func, &#39;bar&#39;);
$snidel-&amp;gt;fork($func, &#39;baz&#39;);

var_dump($snidel-&amp;gt;get());
// * the order of results is not guaranteed. *
// array(3) {
//   [0]=&amp;gt;
//   string(3) &amp;quot;bar&amp;quot;
//   [1]=&amp;gt;
//   string(3) &amp;quot;foo&amp;quot;
//   [2]=&amp;gt;
//   string(3) &amp;quot;baz&amp;quot;
// }

echo (time() - $s) . &#39;sec elapsed&#39; . PHP_EOL;
// 3sec elapsed.

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;作り始めたきっかけ:6059c22da48c7213647847cb35fc5a38&#34;&gt;作り始めたきっかけ&lt;/h3&gt;

&lt;p&gt;仕事で携わっているプロジェクトでは &lt;a href=&#34;https://github.com/squizlabs/PHP_CodeSniffer&#34; target=&#34;_balnk&#34;&gt;PHP_CodeSniffer&lt;/a&gt; を使ってコーディング規約チェックをしていて、規約のエラー数を日次で集計して社内の可視化ツールに結果を投げています。&lt;/p&gt;

&lt;p&gt;その集計に5分くらいかかっていたので、もっと短時間で終わるようにしたいと思ったのがきっかけです。&lt;br /&gt;
php じゃなくても良かったのですが勉強のため。&lt;br /&gt;
いい感じにできれば他のプロジェクトでも使えるかもですし。&lt;/p&gt;

&lt;h3 id=&#34;結果:6059c22da48c7213647847cb35fc5a38&#34;&gt;結果&lt;/h3&gt;

&lt;p&gt;集計処理の時間が下記のように改善しました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ビフォー&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;real 5m9.580s
user 3m3.123s
sys  0m14.849s
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;アフター&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;real 2m44.248s
user 3m1.867s
sys  0m20.341s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行時間が45%くらい削減できました。&lt;br /&gt;
また、実行時間よりユーザーCPU時間の方が長くなっているので
複数のCPUが使えてることがわかります。&lt;/p&gt;

&lt;p&gt;ライブラリの出来としては、github の issues に挙げていますが&lt;br /&gt;
まだ課題があったりするのでもう少しいじりながら楽しみたいと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About Hugo</title>
      <link>http://ackintosh.github.io/about/</link>
      <pubDate>Wed, 09 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ackintosh.github.io/about/</guid>
      <description>

&lt;p&gt;Hugo is a static site engine written in Go.&lt;/p&gt;

&lt;p&gt;It makes use of a variety of open source projects including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;Cobra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;Viper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/jWalterWeatherman&#34;&gt;J Walter Weatherman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cast&#34;&gt;Cast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Learn more and contribute on &lt;a href=&#34;https://github.com/spf13&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;setup:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;Setup&lt;/h2&gt;

&lt;p&gt;Some fun facts about &lt;a href=&#34;http://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Built in &lt;a href=&#34;http://golang.org/&#34;&gt;Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Loosely inspired by &lt;a href=&#34;http://jekyllrb.com/&#34;&gt;Jekyll&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Primarily developed by &lt;a href=&#34;http://spf13.com/&#34;&gt;spf13&lt;/a&gt; on the train while commuting to and from Manhattan.&lt;/li&gt;
&lt;li&gt;Coded in &lt;a href=&#34;http://vim.org&#34;&gt;Vim&lt;/a&gt; using &lt;a href=&#34;http://vim.spf13.com/&#34;&gt;spf13-vim&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Have questions or suggestions? Feel free to &lt;a href=&#34;https://github.com/spf13/hugo/issues/new&#34;&gt;open an issue on GitHub&lt;/a&gt; or &lt;a href=&#34;https://twitter.com/spf13&#34;&gt;ask me on Twitter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thanks for reading!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>phpでバイナリ / テキストファイルの判定</title>
      <link>http://ackintosh.github.io/blog/2014/02/01/is-binary-in-php/</link>
      <pubDate>Sat, 01 Feb 2014 16:25:32 +0900</pubDate>
      
      <guid>http://ackintosh.github.io/blog/2014/02/01/is-binary-in-php/</guid>
      <description>

&lt;p&gt;拡張子での判定は、除外対象のメンテが必要になったりするので今回はボツです。&lt;/p&gt;

&lt;p&gt;最良の方法か分かりませんが、ファイル内にnull文字が含まれる場合にバイナリファイルとして判定するようにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
$result = preg_match(&#39;#\0#&#39;, file_get_contents($file));

if ($result === 1) {
    echo &#39;binary&#39;;
} elseif ($result === 0) {
    echo &#39;text&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;より良い方法がありましたらご教授ください m(＿ ＿)m&lt;/p&gt;

&lt;h4 id=&#34;2014-04-06-追記:ebfc352457f3cfb2fcffd00182127a2f&#34;&gt;2014-04-06 追記&lt;/h4&gt;

&lt;p&gt;はてブでコメントいただいた方法を試しました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NULLバイトを含むかの判定だけなので strpos で事足りる。&lt;/li&gt;
&lt;li&gt;対象ファイルのサイズが大きいと色々と困るので stream を使う。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
function is_binary($file) {
    $fp = fopen($file, &#39;r&#39;);
    while ($line = fgets($fp)) {
        if (strpos($line, &#39;\0&#39;) !== false) {
            fclose($fp);
            return true;
        }
    }

    fclose($fp);
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;900MB のバイナリファイルを使って、最初のスクリプトと実行時間を比較しました。&lt;/p&gt;

&lt;h5 id=&#34;最初のスクリプト:ebfc352457f3cfb2fcffd00182127a2f&#34;&gt;最初のスクリプト&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;$ time php 1.php
php 1.php  0.37s user 2.09s system 6% cpu 35.830 total
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;改善後:ebfc352457f3cfb2fcffd00182127a2f&#34;&gt;改善後&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;$ time php 2.php
php 2.php  0.04s user 0.02s system 49% cpu 0.116 total
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全然違う…！(・∀・)&lt;br /&gt;
最初のなんか、時間を測る以前に Allowed memory size&lt;br /&gt;
エラーが出ちゃいました。。&lt;/p&gt;

&lt;p&gt;大変勉強になりました m(＿ ＿)m&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>クラス / 関数宣言だけをインクルードできるライブラリを作りました</title>
      <link>http://ackintosh.github.io/blog/2013/11/24/toumi/</link>
      <pubDate>Sun, 24 Nov 2013 15:35:00 +0900</pubDate>
      
      <guid>http://ackintosh.github.io/blog/2013/11/24/toumi/</guid>
      <description>&lt;p&gt;クラスや関数の宣言と諸々の処理がごちゃ混ぜに書かれてるスクリプトをメンテナンスする時、&lt;br /&gt;
リファクタリングするためにテストを書きたいけど、テストを書くためにはリファクタリングしないと…(＊_＊) という状況ありませんか？&lt;/p&gt;

&lt;p&gt;例えば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
require_once &#39;xxx.php&#39;;

function hoge($arg)
{
    return &#39;hoge&#39; . $arg;
}

somefunction(1234);

set(&#39;hoge&#39;, hoge(&#39;fuga&#39;));
render(&#39;hoge.html&#39;);
exit;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じのコードがあって、hoge()関数のテストを書きたい時
関数宣言の部分だけインクルードできれば、既存コードに一切手を入れずにテスト書き始められます。&lt;/p&gt;

&lt;p&gt;ということで作りました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ackintosh/toumi&#34; target=&#34;_blank&#34;&gt;ackintosh /
toumi&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;このライブラリを使って上記スクリプトをインクルードすれば、
下記のようにテストが書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
// Only the function declaration is included.
Ackintosh_Toumi::load(&#39;legacy.php&#39;);

class LegacyTest extends PHPUnit_Framework_TestCase
{
    public function test_hoge()
    {
        $this-&amp;gt;assertSame(&#39;hogefuga&#39;, hoge(&#39;fuga&#39;));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そもそもこれを使わずに済めば良いんですが…(・_・;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>spika hackathonに参加しました</title>
      <link>http://ackintosh.github.io/blog/2013/10/21/spika-hackathon/</link>
      <pubDate>Mon, 21 Oct 2013 15:59:43 +0900</pubDate>
      
      <guid>http://ackintosh.github.io/blog/2013/10/21/spika-hackathon/</guid>
      <description>

&lt;p&gt;先日、&lt;a href=&#34;http://connpass.com/event/3698/&#34; target=&#34;_blank&#34;&gt;spika hackathon&lt;/a&gt;に参加してきました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://spikaapp.com/ja/&#34; target=&#34;_blank&#34;&gt;Spika - world first opensource messenger for ios/android&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;今回のハッカソン関係者のみなさんもブログに書かれていますので、
Spikaについてとか、ハッカソン開催の経緯や技術的なことについてはこちらを見てください。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://cloverstudioceo.hatenablog.com/entry/2013/10/21/033700&#34;
target=&#34;_blank&#34;&gt;Spikaを公開して起こった事 -
ヨーロッパで働く社長のブログ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://kuzuha.hatenablog.com/entry/2013/10/21/214116&#34;
target=&#34;_blank&#34;&gt;spika hackathon というのをやった - id:k-z-h&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.yuyat.jp/&#34; target=&#34;_blank&#34;&gt;Spika Hackathon に参加してきた - Born Too Late&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;要するに↑を見れば全てわかるので&lt;br /&gt;
この記事に意味はありません。&lt;/p&gt;

&lt;h4 id=&#34;動機:e043198ef61f2141ba7d1d24b84da36d&#34;&gt;動機&lt;/h4&gt;

&lt;p&gt;この記事を見ている方はご存知だと思いますが、Spikaはコードの品質の低さで話題になりました。&lt;br /&gt;
で、自分もSpikaのコードを見て同じような印象を持ったのですが、&lt;/p&gt;

&lt;p&gt;これなら、自分みたいにショボいプログラマでも何かできるんじゃないか…！？&lt;/p&gt;

&lt;p&gt;と思ったのがハッカソンに参加した動機です。&lt;br /&gt;
（貢献したいというよりは、自分の経験値を上げたいという）&lt;/p&gt;

&lt;p&gt;趣味で一人でgithub使っててもつまらないし&lt;br /&gt;
ソーシャルコーディングとかプルリクエストとか楽しそうだし&lt;br /&gt;
なんかカッコイイなぁ、自分も参加したいなぁと思いながらリポジトリを見渡しても&lt;br /&gt;
何か難しそうだし、英語ばっかりだし(当たり前か…)って感じで悶々とする日々が続いてました。&lt;/p&gt;

&lt;p&gt;なんていうか、高速道路の中央分離帯に立っているような感じで、&lt;br /&gt;
流れに入りたいけど何も出来ない…みたいな(?)。&lt;br /&gt;
なので、それを打破するチャンスかなと思ったので参加しました。&lt;/p&gt;

&lt;h4 id=&#34;やったこと:e043198ef61f2141ba7d1d24b84da36d&#34;&gt;やったこと&lt;/h4&gt;

&lt;p&gt;二人の素晴らしいhackerの隣で黙々とテスト書いてました。&lt;/p&gt;

&lt;p&gt;テストを書こうと最初から決めていたのですが、&lt;br /&gt;
ハッカソン直前にオーナーがSilexで書きなおしてたので、&lt;/p&gt;

&lt;p&gt;やばい！Silex触ったこと無い！&lt;/p&gt;

&lt;p&gt;と、かなり焦りましたがなんとかなりました。&lt;br /&gt;
むしろテスト書きやすかったです。WebTestCaseっていうのがあったので使いました、素晴らしいですね。&lt;br /&gt;
正直、ハッカソンに参加するまでプルリクエスト3回位しかやったことなかったので&lt;br /&gt;
リポジトリの扱いでわからないことがあって参加者の皆さんにご迷惑をかけてしまいました。&lt;/p&gt;

&lt;p&gt;developブランチでSilexで書きなおしてたのに&lt;br /&gt;
自分が間違ってmasterブランチにプルリクエストしてしてしまったり。&lt;br /&gt;
（そしてそれがmergeされてしまったり）&lt;br /&gt;
再度謝罪いたしますm( )m&lt;/p&gt;

&lt;h4 id=&#34;まとめ:e043198ef61f2141ba7d1d24b84da36d&#34;&gt;まとめ&lt;/h4&gt;

&lt;p&gt;やっぱり自分が書いたコードがmergeされた時はちょっとした感動がありました。&lt;br /&gt;
（ハッカソンでは一切表に出しませんでしたが、密かに感動してました）&lt;/p&gt;

&lt;p&gt;あと、自分みたいに高速道路の中央分離帯に立っている人って意外といるんじゃないかなぁと思いますので&lt;br /&gt;
そういう人は、エイッと飛び込んでみると良いかもしれません。&lt;br /&gt;
自分も引き続きがんばります。&lt;/p&gt;

&lt;p&gt;それと、自分は群馬在住なので1日目は都内のカプセルホテルに泊まりました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://travel.rakuten.co.jp/HOTEL/104580/&#34;
target=&#34;_blank&#34;&gt;カプセルランド　湯島 【楽天トラベル】&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;サウナあり、無料モーニングパンサービスありで割と思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>グローバル関数への依存を排除してテスタビリティを上げる</title>
      <link>http://ackintosh.github.io/blog/2013/10/18/php-testability/</link>
      <pubDate>Fri, 18 Oct 2013 17:14:32 +0900</pubDate>
      
      <guid>http://ackintosh.github.io/blog/2013/10/18/php-testability/</guid>
      <description>&lt;p&gt;テストしにくい状況って色々な原因があると思いますが、&lt;br /&gt;
今回はグローバル関数への依存について。&lt;/p&gt;

&lt;p&gt;例えば下記のコードでは&lt;br /&gt;
receiveDataメソッドの中でmail関数を呼び出しているので&lt;br /&gt;
テストしにくくなっています。&lt;br /&gt;
（テストは書けるけどテスト走らせる度にメールが飛ぶのはアレですね）&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/ackintosh/7026140.js?file=1.php&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;a
href=&#34;http://www.amazon.co.jp/%E3%83%AC%E3%82%AC%E3%82%B7%E3%83%BC%E3%82%B3%E3%83%BC%E3%83%89%E6%94%B9%E5%96%84%E3%82%AC%E3%82%A4%E3%83%89-Object-Oriented-SELECTION-%E3%83%9E%E3%82%A4%E3%82%B1%E3%83%AB%E3%83%BBC%E3%83%BB%E3%83%95%E3%82%A7%E3%82%B6%E3%83%BC%E3%82%BA/dp/4798116831&#34;
target=&#34;_blank&#34;&gt;レガシーコード改善ガイド&lt;/a&gt;では&lt;br /&gt;
グローバル関数の部分をインスタンスメソッドにして、処理をグローバル関数にまるっと委譲することで、接合部を作る方法が紹介されています。&lt;br /&gt;
例えばこんな感じでしょうか。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/ackintosh/7026140.js?file=2.php&#34;&gt;&lt;/script&gt;

&lt;p&gt;接合部となったメソッドをサブクラスでオーバーライドしてテストしてます。&lt;/p&gt;

&lt;p&gt;ただ、わざわざサブクラスを定義するのも面倒な気もするし&lt;br /&gt;
もう少しカジュアルな方法がないかなということで&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/ackintosh/7026140.js?file=3.php&#34;&gt;&lt;/script&gt;

&lt;p&gt;テストのためにややプロダクションコードが増えますがメソッドの差し替えができるようになりました。&lt;/p&gt;

&lt;p&gt;ちなみに、無名関数の中でアサーションが書けるのでmail関数が受け取る引数をアサートすることもできます。&lt;/p&gt;

&lt;p&gt;こんな感じです。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/ackintosh/7026140.js?file=4.php&#34;&gt;&lt;/script&gt;

&lt;p&gt;ここまで書いておいてあれですが、こちらにもっと良い方法が解説されていました。&lt;br /&gt;
&lt;a href=&#34;http://phpmentors.jp/post/46982737824&#34; target=&#34;_blank&#34;&gt;PHPメンターズ -&amp;gt; 時計オブジェクト（ドメインクロック）を導入してテスト容易性と意図性を高める&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>遅延静的束縛は何が嬉しいのか</title>
      <link>http://ackintosh.github.io/blog/2013/08/25/late-static-binding/</link>
      <pubDate>Sun, 25 Aug 2013 17:23:38 +0900</pubDate>
      
      <guid>http://ackintosh.github.io/blog/2013/08/25/late-static-binding/</guid>
      <description>

&lt;p&gt;名前は見かけていたものの、いまいち理解していなかった。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://php.net/manual/ja/language.oop5.late-static-bindings.php&#34;
target=&#34;_blank&#34;&gt;PHP: 遅延静的束縛 (Late Static Bindings) - Manual&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;PHP 5.3.0 以降、PHP に遅延静的束縛と呼ばれる機能が搭載されます。
これを使用すると、静的継承のコンテキストで呼び出し元のクラスを参照できるようになります。
より正確に言うと、遅延静的束縛は直近の “非転送コール”
のクラス名を保存します。
静的メソッドの場合、これは明示的に指定されたクラス (通常は ::
演算子の左側に書かれたもの)
となります。静的メソッド以外の場合は、そのオブジェクトのクラスとなります。
“転送コール” とは、self:: や parent::、static:: による静的なコール、
あるいはクラス階層の中での forward_static_call()
によるコールのことです。 get_called_class()
関数を使うとコール元のクラス名を文字列で取得できます。 static::
はこのクラスのスコープとなります。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;遅延静的束縛が無いと困るとき:82199bf342f0eedb2320f9dff2d034e5&#34;&gt;遅延静的束縛が無いと困るとき&lt;/h4&gt;

&lt;script src=&#34;https://gist.github.com/ackintosh/6332540.js?file=1.php&#34;&gt;&lt;/script&gt;

&lt;p&gt;1,400,000が出力されるかと思いきや、0でした。&lt;br /&gt;
・・・期待していたのと違う。&lt;/p&gt;

&lt;h4 id=&#34;selfについて:82199bf342f0eedb2320f9dff2d034e5&#34;&gt;selfについて&lt;/h4&gt;

&lt;p&gt;PHP Manualにはこう書かれています。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;self:: あるいは CLASS による現在のクラスへの静的参照は、
そのメソッドが属するクラス (つまり、 そのメソッドが定義されているクラス)
に解決されます。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;つまり上記のコードでいうと、getFormattedPriceメソッドはCarクラスで定義されているので、&lt;br /&gt;
&lt;code&gt;self::$price&lt;/code&gt; は常に &lt;code&gt;Car::$price&lt;/code&gt; に解決されることになります。&lt;/p&gt;

&lt;p&gt;これでは、いくらCarのサブクラスでgetFormattedPriceを呼び出しても価格の出力ができません。&lt;/p&gt;

&lt;h4 id=&#34;遅延静的束縛を使う:82199bf342f0eedb2320f9dff2d034e5&#34;&gt;遅延静的束縛を使う&lt;/h4&gt;

&lt;p&gt;selfの代わりにstaticを使います。
&lt;script src=&#34;https://gist.github.com/ackintosh/6332540.js?file=2.php&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;これで期待した通りの結果になりました。&lt;/p&gt;

&lt;h4 id=&#34;staticについて:82199bf342f0eedb2320f9dff2d034e5&#34;&gt;staticについて&lt;/h4&gt;

&lt;p&gt;PHP Manualより&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;実行時に最初にコールされたクラスを参照するようにしています。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;これにより、&lt;code&gt;static::$price&lt;/code&gt; が &lt;code&gt;NissanNote::$price&lt;/code&gt; に解決されたことになります。&lt;/p&gt;

&lt;h4 id=&#34;もう少し深く:82199bf342f0eedb2320f9dff2d034e5&#34;&gt;もう少し深く&lt;/h4&gt;

&lt;p&gt;ただ、「最初にコールされたクラスを参照する」というのは少し浅い説明かもしれません。&lt;br /&gt;
Manualには下記のようにも書かれています。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;より正確に言うと、遅延静的束縛は直近の “非転送コール” のクラス名を保存します。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;例えば、
&lt;script src=&#34;https://gist.github.com/ackintosh/6332540.js?file=3.php&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;上記コードだと、staticキーワードが「 最初にコールされたクラス 」を参照しているならば&lt;br /&gt;
&lt;code&gt;NissanNote::getDescription();&lt;/code&gt; メソッド呼び出しの結果、&lt;code&gt;static::$price&lt;/code&gt; は
&lt;code&gt;NissanNote::$price&lt;/code&gt; に解決されるはずですが&lt;br /&gt;
実際には &lt;code&gt;Car::$price&lt;/code&gt; に解決されています。&lt;/p&gt;

&lt;p&gt;これは、「 遅延静的束縛は直近の “非転送コール” のクラス名を保存する 」と考えると理解できます。&lt;/p&gt;

&lt;p&gt;つまり、&lt;br /&gt;
&lt;code&gt;static::$price&lt;/code&gt; の直近の非転送コールは &lt;code&gt;Car::getFormattedPrice()&lt;/code&gt;&lt;br /&gt;
なので&lt;br /&gt;
&lt;code&gt;static::$price&lt;/code&gt; は &lt;code&gt;Car::$price&lt;/code&gt; に解決されたことになります。&lt;/p&gt;

&lt;p&gt;非転送コールについては、下記リンクが大変参考になりました。&lt;/p&gt;

&lt;h4 id=&#34;参考にさせていただきました:82199bf342f0eedb2320f9dff2d034e5&#34;&gt;参考にさせていただきました。&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a
href=&#34;http://d.hatena.ne.jp/maeharin/20130202/php_late_static_bindings&#34;
target=&#34;_blank&#34;&gt;PHPを愛する試み ～self:: parent:: static:: および遅延静的束縛～&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ibm.com/developerworks/jp/opensource/library/os-php-53static/&#34; target=&#34;_blank&#34;&gt;PHP V5.3 で遅延静的バインディングを使ったオブジェクト指向プログラミングを活用する&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ハイフンとアンダースコアの使い分け</title>
      <link>http://ackintosh.github.io/blog/2013/08/11/hypen-under-score/</link>
      <pubDate>Sun, 11 Aug 2013 16:10:19 +0900</pubDate>
      
      <guid>http://ackintosh.github.io/blog/2013/08/11/hypen-under-score/</guid>
      <description>

&lt;p&gt;ネーミングの時のハイフンとアンダースコアの使い分けが、自分の中で曖昧なところがあったのでメモ。&lt;/p&gt;

&lt;p&gt;言語やフレームワークによって色々あるかもしれませんが、以下、Ruby(gem)の場合です。&lt;/p&gt;

&lt;h4 id=&#34;eric-hodel氏の推奨するネーミングルール:9f67e2a979143e636a28a8963816fa9d&#34;&gt;Eric Hodel氏の推奨するネーミングルール&lt;/h4&gt;

&lt;p&gt;RubyGemsの作者、Eric Hodel氏は自身のブログで次のように推奨しています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.segment7.net/2010/11/15/how-to-name-gems&#34;
target=&#34;_blank&#34;&gt;How to Name Gems&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Here is my STRONG recommendation on how to name gems:
Use underscores
・fancy_require
・newrelic_rpm
・ruby_parser
This matches the file the user will require and makes it easier for the
user to start using your gem. gem install my_gem will be loaded by
require ‘my_gem’.
Use dashes for extensions
・net-http-persistent
・rdoc-chm
・autotest-growl
If you’re adding functionality to another gem use a dash. The dash is
different-enough from an underscore to be noticeable. If you tilt the
dash a bit it becomes a slash as well, making it easier for the user to
know what to require. gem install net-http-persistent becomes require
‘net/http/persistent’
要するに&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ハイフン -&amp;gt; パスの区切り&lt;br /&gt;
アンダースコア -&amp;gt; 単語の区切り&lt;br /&gt;
といったところでしょうか。&lt;/p&gt;

&lt;h4 id=&#34;試してみる:9f67e2a979143e636a28a8963816fa9d&#34;&gt;試してみる&lt;/h4&gt;

&lt;h5 id=&#34;ハイフン区切り:9f67e2a979143e636a28a8963816fa9d&#34;&gt;ハイフン区切り&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;$ bundle gem ackintosh-tiny-progressbar
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;module Ackintosh
  module Tiny
    module Progressbar
      # Your code goes here ...
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全て別のモジュールに分かれています。&lt;/p&gt;

&lt;h5 id=&#34;アンダースコア区切り:9f67e2a979143e636a28a8963816fa9d&#34;&gt;アンダースコア区切り&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;$ bundle gem ackintosh-tiny_progressbar
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;module Ackintosh
  module TinyProgressbar
    # Your code goes here…
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「tiny」と「progressbar」は別の単語ですが意味的には１つになっています。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>